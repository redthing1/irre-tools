#+TITLE: LEG architecture tools

* leg tools
the [[https://github.com/xdrie/llvm-leg][LEG toolchain]] can compile C
to the LEG architecture.
 
this is extremely useful for REGULAR because LEG is a minimal
register-based RISC machine, as is REGULAR, and LEG appears to be
trivially implementable as a strict subset of REGULAR.
 
* leg architecture spec
  :PROPERTIES:
  :CUSTOM_ID: leg-spec
  :END:
 
information/documentation on the LEG architecture comes from these two presentations by its authors:
+ [[https://web.archive.org/web/20200611030201/http://www.inf.ed.ac.uk/teaching/courses/ct/other/LLVMBackend-2015-03-26_v2.pdf][presentation]] (p.Â 11-15)
+ [[https://web.archive.org/web/20200611031116/http://llvm.org/devmtg/2014-04/PDFs/Talks/Building%20an%20LLVM%20backend.pdf][presentation]] (p. 6-7)
 
** summary
+ simple, RISC-like architecture
  + tiny subset of ARM
+ 12 32-bit integer registers
  + ~r0~ through ~r9~, and ~sp~ (stack pointer) and ~lr~ (return address)
+ instructions
  + 32-bit arithmetic (add, sub, mul, mad (?))
  + 32-bit register move, 16-bit constant moves
  + 32-bit load/store
  + integer comparison, branch, branch and link
+ calling convention
  + arguments 1-4 passed in ~r0~ through ~r3~
  + further arguments passed on stack
  + return value in ~r0~
 
** examples
*** add function
+ function adding integers
  + arguments passed in registers (~r0~ through ~r2~)
  + return value stored in ~r0~
+ returns to the caller using ~b~ (branch)
  + ~lr~ contains the return address

the function:
#+begin_src c
int add(int a, int b) {
    int result = a + b;
    return result;
}
#+end_src

translates to:
#+begin_src asm
.add:
    add r0, r0, r1  
    b lr
#+end_src
*** memory function
+ a function that loads a value, adds a constant, and stores result
  + ~ldr~ loads a value from memory
  + ~mov~ copies an imm to a register
  + ~str~ stores the value to memory
  
sample code:
#+begin_src c
void ex7(int *src, int *dst) {
    int x = src[0];
    int reuslt = x + 42;
    dst[0] = result; 
}
#+end_src

compiles to:
#+begin_src asm
ex7:
    ldr r0, [r0]
    mov r2, #42
    add r0, r0, r2
    bx lr
#+end_src
*** branching function
+ function that either adds or subtracts two integers
+ the result depends on which argument is greater
  + ~cmp~ compares the arguments
  + ~b~ branches to the ~if_else~ basic block, using:
    + the ~le~ predicate
    + the implicit condition flag register set by ~cmp~
  + fall through to ~if_then~ if the predicate doesn't match
  
this example code:
#+begin_src c
int ex6(int a, int b) {
    if (a > b) {
        return a + b;
    } else {
        return a - b;
}
#+end_src

compiles to assembly:
#+begin_src asm
.ex6:
    cmp r0, r1
    ble .if_else
.if_then:
    add r0, r0, r1
    bx lr
.if_else
    sub r0, r0, r1
    bx lr
#+end_src

* building leg
leg source code exists in two places, namely the original branch that the code was released for, and a pair of [[https://github.com/frasercrmck/llvm-leg][updated]] [[https://github.com/xdrie/clang-leg][repositories]] with slightly newer LLVM and Clang versions.

for archival and tweaking purposes, we provide the following forked repositories:
+ [[https://github.com/xdrie/llvm-leg][llvm-leg]]
+ [[https://github.com/xdrie/clang-leg][clang-leg]]

while the build instructions in those repos have been left mostly unmodified, the process will be again described in detail here.


