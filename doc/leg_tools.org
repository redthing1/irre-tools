#+TITLE: LEG architecture tools

* leg tools
the [[https://github.com/xdrie/llvm-leg][LEG toolchain]] can compile C
to the LEG architecture.
 
this is extremely useful for REGULAR because LEG is a minimal
register-based RISC machine, as is REGULAR, and LEG appears to be
trivially implementable as a strict subset of REGULAR.
 
* leg architecture spec
  :PROPERTIES:
  :CUSTOM_ID: leg-spec
  :END:
 
information/documentation on the LEG architecture comes from these two presentations by its authors:
+ [[https://web.archive.org/web/20200611030201/http://www.inf.ed.ac.uk/teaching/courses/ct/other/LLVMBackend-2015-03-26_v2.pdf][presentation]] (p.Â 11-15)
+ [[https://web.archive.org/web/20200611031116/http://llvm.org/devmtg/2014-04/PDFs/Talks/Building%20an%20LLVM%20backend.pdf][presentation]] (p. 6-7)
 
** summary
+ simple, RISC-like architecture
  + tiny subset of ARM
+ 12 32-bit integer registers
  + ~r0~ through ~r9~, and ~sp~ (stack pointer) and ~lr~ (return address)
+ instructions
  + 32-bit arithmetic (add, sub, mul, mad (?))
  + 32-bit register move, 16-bit constant moves
  + 32-bit load/store
  + integer comparison, branch, branch and link
+ calling convention
  + arguments 1-4 passed in ~r0~ through ~r3~
  + further arguments passed on stack
  + return value in ~r0~
 
** examples
*** add function
+ function adding integers
  + arguments passed in registers (~r0~ through ~r2~)
  + return value stored in ~r0~
+ returns to the caller using ~b~ (branch)
  + ~lr~ contains the return address

the function:
#+begin_src c
int add(int a, int b) {
    int result = a + b;
    return result;
}
#+end_src

translates to:
#+begin_src asm
.add:
    add r0, r0, r1  
    b lr
#+end_src
*** memory function
+ a function that loads a value, adds a constant, and stores result
  + ~ldr~ loads a value from memory
  + ~mov~ copies an imm to a register
  + ~str~ stores the value to memory
  
sample code:
#+begin_src c
void ex7(int *src, int *dst) {
    int x = src[0];
    int reuslt = x + 42;
    dst[0] = result; 
}
#+end_src

compiles to:
#+begin_src asm
ex7:
    ldr r0, [r0]
    mov r2, #42
    add r0, r0, r2
    bx lr
#+end_src
*** branching function
+ function that either adds or subtracts two integers
+ the result depends on which argument is greater
  + ~cmp~ compares the arguments
  + ~b~ branches to the ~if_else~ basic block, using:
    + the ~le~ predicate
    + the implicit condition flag register set by ~cmp~
  + fall through to ~if_then~ if the predicate doesn't match
  
this example code:
#+begin_src c
int ex6(int a, int b) {
    if (a > b) {
        return a + b;
    } else {
        return a - b;
}
#+end_src

compiles to assembly:
#+begin_src asm
.ex6:
    cmp r0, r1
    ble .if_else
.if_then:
    add r0, r0, r1
    bx lr
.if_else
    sub r0, r0, r1
    bx lr
#+end_src

* building leg
leg source code exists in two places, namely the original branch that the code was released for, and a pair of [[https://github.com/frasercrmck/llvm-leg][updated]] [[https://github.com/xdrie/clang-leg][repositories]] with slightly newer LLVM and Clang versions.

for archival and tweaking purposes, we provide the following forked repositories:
+ [[https://github.com/xdrie/llvm-leg][llvm-leg]]
+ [[https://github.com/xdrie/clang-leg][clang-leg]]

while the build instructions in those repos have been left mostly unmodified, the process will be again described in detail here.

first, obtain all relevant source code:
#+begin_src sh
# get the LLVM source
git clone https://github.com/xdrie/llvm-leg
cd llvm-leg
# get the clang source (technically optional, but required to compile C in addition to LLVM IR, which is supported by the rest of LLVM)
git clone https://github.com/xdrie/clang-leg tools/clang
#+end_src

as for compiling, i was unable to build the repos using a modern version of Clang. instead, follow the suggestion of the tested compiler ~gcc-4.9~. this worked for me in 2020-06.

#+begin_src sh
mkdir build && cd build
# generate the ninja build files
CC=/usr/bin/gcc-4.9 CXX=/usr/bin/g++-4.9 cmake -G "Ninja" "-DCMAKE_BUILD_TYPE:STRING=DEBUG" "-DLLVM_TARGETS_TO_BUILD:STRING=LEG" ../
# compile
ninja
#+end_src

this will create binaries in ~build/bin~ from the repo root.
to compile C source to ~.s~ LEG assembly:
#+begin_src sh
./build/bin/clang -cc1 -triple leg-unknown-unknown -S -o ex1.s docs/Codeplay/examples/ex1/ex1.c
#+end_src

sample output (contents of ~ex1.s~):
#+begin_src asm
	.text	.file	"docs/Codeplay/examples/ex1/ex1.c"
	.globl	foo
	.type	foo,@function
foo:
	sub sp, sp, #20
	mov r2, r1
	mov r3, r0
	str r0, [sp, #16]
	str r1, [sp, #12]
	ldr r0, [sp, #16]
	add r0, r0, r1
	str r0, [sp, #8]
	str r2, [sp, #4]
	str r3, [sp]
	add sp, sp, #20
	bx lr
.Lfunc_end0:
	.size	foo, .Lfunc_end0-foo


	.ident	"clang version 3.8.1 (https://github.com/frasercrmck/clang-leg.git 43d93776c0f686e0097b8e3c96768b716ccd0a88) (https://github.com/frasercrmck/llvm-leg.git 639b36ab242152752905edfea54ea571682b6f81)"
	.section	".note.GNU-stack","",@progbits
#+end_src


